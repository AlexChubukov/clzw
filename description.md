# Описание программы

## Краткое описание логики
Для работы программы был написан класс LZW, находящийся в собсвенном пространстве имен. Класс Не содержит полей, только методы для сжатия и распаковки файлов, которые принимают на вход пути до входного и выходного файла. Все проверки на открытие и существования файлов делаются внутри методов, в случае, если что-то не так, бросается исключение. Также исключения бросаются в самом начале программы, когда проверятся корректно ли введены аргументы командной строки. Также класс содержит методы для инициализации словарей начальным алфавитом для сжатия и распаковки. В файле LZW.cpp содержатся две дополнительные функции CharToShort() и shortToBytes() преоразующие соответственно массив байт в число типа unsigned short и наоборот. Программа не выводит никакой информации в консоль. Если в консоль ничего не вывелось, это значит программа отработала без ошибок, в противном случае будет возбуждено исключение и оно выведется в консоль.


## Использованные структуры данных
В программе использовался std::unordered_map из библиотки STL, являющийся ассоциативным массивом(хэш-таблицей), для хранения пар (слово, число) и (число, слово). Использовался std::unordered_map, а не std::map, так как в программе необходимо было константное время проверки наличия значения в словаре.

std::vector<char> использовался для локального хранения массива бит, когда нужно было преобразовать unsigned short в поток байт и вывести в файл.


## Оценка сложности
Функции initialize_dictionary() инициализируют словарь за один проход причем время инициализации не зависит от входных данных(O(1)).
Функция compress() и decompress() являются однопроходными, причем каждый символ файла считывается ровно один раз. То есть данные функции линейно зависят от размера файлов. При каждой итерации цикла происходят сравнения, а также проверка на принадлежность слова словарю, которая осуществляется за константное время. Таким образом функции линейно зависят от входных данных.

Так как при выходе из метода работа программы по сути завершается, то получаем, что общая сложность алгоритма линейная, то есть O(n)


## Оценка использования памяти
Программа использует дополнительную память для хранения словаря, а также для хранения текущего подслова. Также есть и дргуие локальные переменные, но они всегда занимают O(1) памяти.
В словаре хранятся пары в формате <std::string, unsigned short>. Я использую unsigned short, который в языке С++ занимает 2 байта памяти, для того чтобы оптимизировать процесс по памяти. Данный тип данных был получен эвристическим путем, так как для больших файлов размером в несколько мегабайт словарь заполняется полностью. Оценим использование памяти в таком случае. Так как словарь заполнен полностью, это значит, что в нем лежит (2^16 - 1) = 65535 возможных пар. unsigned short занимает 2 байта, std::string занимает 8 байт(было получено экспериментальным путем через функции sizeof() и capacity() запуском от разных строк). Соответственно одна пара занимает 10 байт. Всего таких пар 65535, значит суммарно используется 655350 Байт =640 Мб. Если бы испльзовался не unsigned short, а int, то размер словаря был бы равен (2^32-1)x10 Б = 40 Тб.
Даже если словарь будет занимать весь объем памяти выделенной под процесс (4Гб), то размер максимальный размер словаря будет равен 419430 слов. Для хранения такого количества слов требуется 19 бит. А для хранения unsigned short используется 16 бит.
При поступлении на вход случайного текста частота встречаемости каждого символа будет равна частоте встречаемости букв данного алфавита. Из этих соображений можно продположить, что новые последовательности будут добавляться в словарь допольно часто. Так как в каждом алфавите существуют комбинации, которые встречаются чаще всего(двойки и триплеты наиболее популярных комбинаций), то можно предположить, что в случайном тексте будет добавляться каждая пятая последовательность символов. Общий размер словаря в данном случае равен O(0.2* n* 10). А это значит, что асимптотически размер словаря равен O(n). Однако в худшем случае, когда словарь будет заполнен полностью размер словаря не превысит 640 Мб.