# Описание программы

## Краткое описание логики
Для работы программы был написан класс LZW, находящийся в собсвенном пространстве имен. Класс Не содержит полей, только методы для сжатия и распаковки файлов, которые принимают на вход пути до входного и выходного файла. Все проверки на открытие и существования файлов делаются внутри методов, в случае, если что-то не так, бросается исключение. Также исключения бросаются в самом начале программы, когда проверятся корректно ли введены аргументы командной строки. Также класс содержит методы для инициализации словарей начальным алфавитом для сжатия и распаковки. В файле LZW.cpp содержатся две дополнительные функции CharToShort() и shortToBytes() преоразующие соответственно массив байт в число типа unsigned short и наоборот. Программа не выводит никакой информации в консоль. Если в консоль ничего не вывелось, это значит программа отработала без ошибок, в противном случае будет возбуждено исключение и оно выведется в консоль.


## Использованные структуры данных
В программе использовался std::unordered_map из библиотки STL, являющийся ассоциативным массивом(хэш-таблицей), для хранения пар (слово, число) и (число, слово). Использовался std::unordered_map, а не std::map, так как в программе необходимо было константное время проверки наличия значения в словаре.

std::vector<char> использовался для локального хранения массива бит, когда нужно было преобразовать unsigned short в поток байт и вывести в файл.


## Оценка сложности
Функции initialize_dictionary() инициализируют словарь за один проход причем время инициализации не зависит от входных данных(O(1)).
Функция compress() и decompress() являются однопроходными, причем каждый символ файла считывается ровно один раз. То есть данные функции линейно зависят от размера файлов. При каждой итерации цикла происходят сравнения, а также проверка на принадлежность слова словарю, которая осуществляется за константное время. Таким образом функции линейно зависят от входных данных.

Так как при выходе из метода работа программы по сути завершается, то получаем, что общая сложность алгоритма линейная, то есть O(n)


## Оценка использования памяти
Программа использует дополнительную память для хранения словаря, а также для хранения текущего подслова. Также есть и дргуие локальные переменные, но они всегда занимают O(1) памяти.
А так как словарь довольно быстро расширяется на случайных текстах, но можно скзать, что размер словаря, а значит и дополнителной памяти линейно зависит от входных данных O(n).